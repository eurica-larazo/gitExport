#!/bin/bash

# Colors
RED='\033[0;31m'
BLUE='\033[0;34m'
GREEN='\033[0;32m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
ORANGE='\033[0:33m'
NC='\033[0m'

# Get params
for var in "$@"
do
        IFS='=' read -a param <<< "$var"

        if [ ${param[0]} == "path" ]; then
                path=${param[1]}
        elif [ ${param[0]} == "since" ]; then
                since==${param[1]}
        elif [ ${param[0]} == "until" ]; then
                until==${param[1]}
        elif [ ${param[0]} == "commit" ]; then
                commit=${param[1]}
        fi
done


function filterFiles {
	dirPath=$path

	while read linePath; do
		if [ -f "$linePath" ]; then
			lowerPathName=$(echo $linePath | tr '[:upper:]' '[:lower:]')

			fileName=$(basename $lowerPathName)
                        if [ "$fileName" != ".ds_store" ]; then
                        
				if [ "$lowerPaths" != "" ]; then
				
					filterFlag=0
					for l in $lowerPaths; do
						if [ "$l" == "$lowerPathName" ]; then
							filterFlag=1
							break
						fi
					done

					if [ $filterFlag -eq 0 ]; then
						if [ -f $linePath ]; then
							lowerPaths="$lowerPaths $lowerPathName"
		                                	filteredCollection="$filteredCollection $linePath"
						fi
					fi
				else
					if [ -f $linePath ]; then
						lowerPaths="$lowerPaths $lowerPathName"
						filteredCollection="$filteredCollection $linePath"
					fi
				fi
			fi
		fi
	done < $dirPath
	
	filteredCollection=$(echo "$filteredCollection" | tr " " "\n"|sort|uniq)

	printf '%s\n' $filteredCollection > $dirPath;
	
}

# Check for first param (path)
if [ "$path" ]; then

	# Get folder location
	counter=1
	listfiles=$(echo $path | tr "\/" "\n")
	listfileslen=$(echo "$listfiles" | wc -l)	

	for l in $listfiles; do
	        counter=$((counter+1))
	        if [ $counter -eq $listfileslen ]; then
        	        filename=$l
	        else
                	locpath="$locpath/$l"
        	fi
	done
	
	# Check if folder location exist
	if [ -d "$locpath" ]; then
	
		if [ $since ]; then
			if [ $until ]; then
				printf "${PURPLE}Exporting files from $since to $until.${NC}\n"
	                        commit=$(git log --since="$since" --until="$until" | grep -E -o '[0-9a-f]{40}')
			else
				printf "${PURPLE}Exporting files from .${NC}\n"
				commit=$(git log --since="$since" | grep -E -o '[0-9a-f]{40}')
			fi
		else
			printf "${PURPLE}Exporting files from the beginning.${NC}\n"
			commit=$(git log | grep -E -o '[0-9a-f]{40}')
		fi

		for c in $commit; do
	
			ismerge=$(test -z $(git rev-parse --verify $c^2 2> /dev/null) || echo "MERGE")

			if [ "$ismerge" != "MERGE" ]; then
				ufiles=$(git diff-tree --no-commit-id --name-only -r $c | grep -v 'var\/')
				totalfiles=$(echo "$ufiles" | wc -l)

				if [ $totalfiles -lt 500 ]; then
					commitmsg=$(git log --format=%B -n 1 $c)
					commitmsg=$(echo $commitmsg | tr -d '%')
		                	printf "${ORANGE}Updated Files:$totalfiles${NC} - ${GREEN}Commit:${NC} ${CYAN}$commitmsg${NC}\n"

					allfiles="$allfiles $(git diff-tree --no-commit-id --name-only -r $c | grep -v 'var\/')"
				fi
			fi
		done
	
		# Replace all space with new line
		paths=$(echo $allfiles | tr " " "\n")
		
		# Create log file
		printf '%s\n' $paths > git-log.txt;
		
		# Fileter all files (duplicate, not existing file, sort)
		filterFiles "$(pwd)/git-log.txt"

		while read filteredLines; do
			newfileList="$newfileList $filteredLines"
		done < git-log.txt		
	
		allfiles="$newfileList git-log.txt"
	
		tar czf $path $allfiles

		rm git-log.txt

		printf "${GREEN}Export complete.${NC}\n"
	else
		printf "${RED}Invalid Path: Path does not exist${NC}\n"
	fi
else
	printf "${RED}Undefined Path: gitExport PATH${NC}\n"
fi
